name: Build SFX release (stable)

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  build_release:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install 7-Zip (with SFX module)
        shell: pwsh
        run: |
          if (-not (Test-Path "$env:ProgramFiles\7-Zip\7z.exe")) {
            choco install 7zip -y
          }
          if (-not (Test-Path "$env:ProgramFiles\7-Zip\7z.sfx")) {
            throw "7z.sfx not found in $env:ProgramFiles\7-Zip"
          }

      - name: Compute version (MAJOR manual, MINOR auto)
        id: ver
        shell: pwsh
        run: |
          $tags = git tag --list "v*.*.*"
          $parsed = @()
          foreach ($t in $tags) {
            if ($t -match '^v(\d+)\.(\d+)\.(\d+)$') {
              $parsed += [pscustomobject]@{
                tag   = $t
                major = [int]$matches[1]
                minor = [int]$matches[2]
                patch = [int]$matches[3]
              }
            }
          }

          if ($parsed.Count -eq 0) {
            $major = 1
            $minor = [int](git rev-list --count HEAD) - 1
            if ($minor -lt 0) { $minor = 0 }
          } else {
            $major = ($parsed | Measure-Object major -Maximum).Maximum
            $majorTags = $parsed | Where-Object { $_.major -eq $major } | Sort-Object minor, patch
            $baseTag = $majorTags[0].tag
            $baseMinor = [int]$majorTags[0].minor
            $commitsSince = [int](git rev-list --count "$baseTag..HEAD")
            $minor = $baseMinor + $commitsSince
          }

          $version = "v$major.$minor.0"
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Build SFX (.exe)
        shell: pwsh
        run: |
          $version = "${{ steps.ver.outputs.version }}"
          $sevenZip = Join-Path $env:ProgramFiles "7-Zip\7z.exe"
          $sfx      = Join-Path $env:ProgramFiles "7-Zip\7z.sfx"

          $archive = "repo_${version}.7z"
          $outExe  = "repo_${version}_stable.exe"

          & $sevenZip a -t7z $archive ".\*" "-xr!.git" | Out-Host

          # ВАЖНО: генерируем config без "сырых" строк в YAML
          $cfg = @(
            ';!@Install@!UTF-8!'
            "Title=""Repository $version (stable)"""
            "BeginPrompt=""Распаковать файлы релиза $version?"""
            'ExtractTitle="Распаковка..."'
            ';!@Install@!UTF-8!'
          ) -join "`r`n"

          Set-Content -Path "config.txt" -Value $cfg -Encoding utf8

          cmd /c "copy /b ""$sfx"" + config.txt + ""$archive"" ""$outExe"""

          "OUT_EXE=$outExe" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Create/update tags (version + stable)
        shell: pwsh
        run: |
          $version = "${{ steps.ver.outputs.version }}"

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          $remote = git ls-remote --tags origin $version
          if ([string]::IsNullOrWhiteSpace($remote)) {
            git tag -a $version -m "Release $version (stable)"
            git push origin $version
          } else {
            Write-Host "Tag $version already exists — skipping."
          }

          git tag -f stable
          git push origin -f stable

      - name: Create or update GitHub Release (stable)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $version = "${{ steps.ver.outputs.version }}"
          $notes = "Авто-стабильный релиз по коммиту $env:GITHUB_SHA. Тег stable указывает на этот релиз."
          
          # Проверяем existence релиза корректно: по коду возврата gh
          gh release view $version 1>$null 2>$null
          $exists = ($LASTEXITCODE -eq 0)
          
          if ($exists) {
            gh release upload $version "$env:OUT_EXE" --clobber
            gh release edit $version --title "$version (stable)" --notes "$notes" --latest
          } else {
            gh release create $version "$env:OUT_EXE" --title "$version (stable)" --notes "$notes" --latest
          }
